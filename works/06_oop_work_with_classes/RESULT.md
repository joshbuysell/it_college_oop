# Звіт до роботи
## Тема: Програмування з використанням ООП
### Мета роботи: Навчитись працювати з Класами та його основними конструкціями

---

## Виконання роботи

### 1. Створення базового класу

Розробили базовий клас `MyAnimals` та навчилися створювати об'єкти:

```python
class MyAnimals:
    pass

a = MyAnimals()
print(f"Тип об'єкта: {type(a)}")
```

**Результат виконання:**
- Створено базовий клас
- Перевірено тип створеного об'єкта
- Навчилися використовувати оператор `type()`

![Базовий клас](assets/01_basic_class.png)

---

### 2. Порівняння простих даних з об'єктами

Розглянули різницю між використанням простих структур даних (списків) та об'єктів класу:

```python
# Прості структури
animals = ["Рибки", "Кіт", "Собака"]
name = ["Неони", "Мурка", "Рекс"]

# Клас
class MyAnimals:
    def __init__(self, animals, name, age, mass=None):
        self.animals = animals
        self.name = name
        self.age = age
        self.mass = 0 if mass == None else mass
```

**Отримано наступні результати:**
- Об'єкти класу зручніші для зберігання пов'язаних даних
- Можна легко змінювати атрибути об'єктів
- Код стає більш читабельним та структурованим

---

### 3. Методи класу

Реалізували методи для роботи з об'єктами:

```python
def speak(self):
    if self.animals == "Кіт":
        return f"Моя Тваринка {self.animals} говорить Мяууу"
    elif self.animals == "Собака":
        return f"Моя Тваринка {self.animals} говорить Гавв"
    else:
        return f"Моя Тваринка {self.animals} не розмовляє"

def add_one_year(self):
    self.age += 1
    return f"Моя Тваринка {self.animals} прожила за мною один рік"
```

**Навчились:**
- Створювати методи класу
- Використовувати `self` для доступу до атрибутів
- Викликати методи на об'єктах

---

### 4. Змінні класу (Class Variables)

Створили глобальні змінні, які спільні для всіх об'єктів класу:

```python
class MyAnimals:
    total_animals = 0
    total_animal_types = set()
    
    def __init__(self, animals, name, age, mass=None):
        # ...
        MyAnimals.total_animal_types.add(animals)
        MyAnimals.total_animals += 1
```

**Програма вивела значення:**
- Загальна кількість створених тварин: 7
- Типи тварин: ['Рибки', 'Кіт', 'Папуга', 'Хом\'як', 'Черепаха']

---

### 5. Статичні методи (@staticmethod)

Реалізували статичні методи, які не потребують доступу до атрибутів об'єкта:

```python
@staticmethod
def call_pet():
    return "Тваринка біжить до нас"

@staticmethod
def pet_advice():
    return "Не забувайте годувати своїх тварин щодня!"
```

**Навчились:**
- Створювати статичні методи з декоратором `@staticmethod`
- Викликати статичні методи як з класу, так і з об'єкта
- Розуміти різницю між звичайними методами та статичними

---

### 6. Робота з Properties (@property)

Створили властивості класу для обчислення значень:

```python
@property
def live_until(self):
    return datetime.today().year - self.age + self.max_age

@property
def age_in_human_years(self):
    if self.animals == "Кіт" or self.animals == "Собака":
        return self.age * 7
    return self.age
```

**Отримано наступні результати:**
- Property дозволяє звертатися до методу як до атрибута
- Автоматичні обчислення при зверненні до властивості
- Код стає більш інтуїтивним

---

### 7. Методи класу (@classmethod)

Реалізували методи класу для створення об'єктів різними способами:

```python
@classmethod
def from_csv(cls, csv_data: str):
    cls.total_csv += 1
    animal, name, age = csv_data.split(",")
    return cls(animal, name, age)

@classmethod
def validate_name(cls, name: str) -> bool:
    if name and name[0].isupper():
        return True
    return False
```

**Навчились:**
- Використовувати декоратор `@classmethod`
- Створювати альтернативні конструктори
- Працювати з параметром `cls`

---

### 8. Приватні атрибути та методи

Розглянули механізм приховування даних:

```python
def __init__(self, animals, name, age):
    self._secret_phrase = "Це приватний атрибут"  # одне підкреслення
    self.__secret_strong = "Сильно приватний!"     # два підкреслення
    
@property
def secret_phrase(self):
    return f"Доступ через property: {self._secret_phrase}"

def _secret_method(self):
    return "Приватний метод"
```

**Навчились:**
- Використовувати `_` для позначення приватних атрибутів (угода)
- Використовувати `__` для сильного приховування (name mangling)
- Створювати property для безпечного доступу до приватних даних

---

### 9. Магічні методи

Реалізували спеціальні методи для контролю поведінки об'єктів:

```python
def __repr__(self) -> str:
    return f'MyAnimals("{self.animals}", "{self.name}", {self.age})'

def __str__(self) -> str:
    return f"Це є об'єкт {self.__repr__()}"

def __eq__(self, other) -> bool:
    if isinstance(other, MyAnimals):
        return self.name == other.name and self.animals == other.animals
    return False
```

**Отримано наступні результати:**
- `__str__` використовується при виклику `print()`
- `__repr__` використовується при виклику `repr()`
- `__eq__` дозволяє порівнювати об'єкти оператором `==`

---

### 10. Арифметичні магічні методи

Реалізували перевантаження операторів:

```python
def __sub__(self, obj):
    if isinstance(obj, MyAnimals):
        return f"Мій {self.name} покусав {obj.name}"
    elif isinstance(obj, int):
        self.age += obj
        return f"Мій {self.name} постарів на {obj} років"

def __gt__(self, obj):
    if isinstance(obj, MyAnimals):
        if self.age > obj.age:
            return f"Старшим є {self.name}"
        return f"{self.name} не є старшим за {obj.name}"

def __len__(self) -> int:
    return len(self.name)
```

**Навчились:**
- Перевантажувати арифметичні оператори (`+`, `-`, `*`)
- Реалізовувати оператори порівняння (`>`, `<`, `==`)
- Використовувати `__len__` для роботи з функцією `len()`

---

## Структура файлів проекту

```
works/05_oop_first_class/
├── oop_first_class.ipynb      # Перша робота з ООП
├── oop_first_class.py          # Python скрипт
├── classes_work.ipynb          # Повна робота з класами
├── users.txt                   # Файл з даними
├── RESULT.md                   # Цей звіт
├── README.md                   # Опис роботи
└── assets/                     # Скріншоти та зображення
```

---

## Посилання на файли

- [Jupyter Notebook з усіма завданнями](classes_work.ipynb)
- [Python скрипт з класом MyName](oop_first_class.py)
- [Перший Notebook з ООП](oop_first_class.ipynb)

---

## Висновок

### ❓ Що зроблено в роботі:
- Виконано всі завдання з файлу `classes.ipynb` з репозиторію it_college
- Створено клас `MyAnimals` з повною функціональністю
- Реалізовано всі типи методів: звичайні, статичні, методи класу
- Працювали з properties, приватними атрибутами, магічними методами
- Виконано додаткові завдання до кожної секції

### ❓ Чи досягнуто мети роботи:
Так, повністю досягнуто. Навчилися працювати з основними конструкціями ООП в Python:
- Створення класів та об'єктів
- Робота з атрибутами та методами
- Використання декораторів (@property, @staticmethod, @classmethod)
- Інкапсуляція через приватні атрибути
- Перевантаження операторів через магічні методи

### ❓ Які нові знання отримано:
1. **Основи ООП**: Розуміння класів, об'єктів, атрибутів та методів
2. **Декоратори**: Використання @property, @staticmethod, @classmethod
3. **Інкапсуляція**: Приватні атрибути (_ та __) та доступ до них
4. **Магічні методи**: __init__, __str__, __repr__, __eq__, __add__, __sub__ та інші
5. **Class variables**: Спільні змінні для всіх об'єктів класу
6. **Name mangling**: Механізм приховування атрибутів з __

### ❓ Чи вдалось відповісти на всі питання задані в ході роботи:
Так, на всі питання отримано відповіді:
- Зрозуміла різниця між простими даними та об'єктами
- Навчилися працювати з різними типами методів
- Розібралися з приватними атрибутами та методами доступу
- Реалізували всі магічні методи з прикладів

### ❓ Чи вдалося виконати всі завдання:
Так, виконано:
- ✅ Всі основні завдання з classes.ipynb
- ✅ Всі додаткові завдання (позначені в notebook)
- ✅ Індивідуальні завдання з розширенням функціональності
- ✅ Оформлення коду згідно PEP 8

### ❓ Чи виникли складності у виконанні завдання:
Невеликі складності виникли при:
- Розумінні різниці між `_` та `__` для приватних атрибутів
- Реалізації name mangling механізму
- Перевантаженні арифметичних операторів з різними типами даних

Однак всі складності вдалося подолати через вивчення документації та експерименти з кодом.

### ❓ Чи подобається такий формат здачі роботи (Feedback):
Так, формат дуже зручний:
- ✅ Jupyter Notebook дозволяє інтерактивно виконувати код
- ✅ Markdown комірки допомагають структурувати матеріал
- ✅ Можна одразу бачити результати виконання
- ✅ Зручно експериментувати та змінювати код
- ✅ Git дозволяє відслідковувати історію змін

### ❓ Побажання для покращення (Suggestions):
1. Додати більше прикладів реальних застосувань класів
2. Включити завдання на наслідування (inheritance)
3. Додати завдання на поліморфізм
4. Більше практичних завдань на композицію класів
5. Приклади роботи з dataclass (Python 3.7+)
6. Завдання на створення власних context managers

---

**Дата виконання:** 10 грудня 2025 р.  
**Виконав:** [Віктор Цвик]  
**Група:** [КН-210]

---

## Додаткові матеріали

### Корисні посилання:
- [Python Documentation - Classes](https://docs.python.org/3/tutorial/classes.html)
- [Real Python - OOP in Python](https://realpython.com/python3-object-oriented-programming/)
- [PEP 8 - Style Guide](https://pep8.org/)

### Використані ресурси:
- Матеріали з репозиторію [BobasB/it_college](https://github.com/BobasB/it_college)
- Лекційні матеріали з курсу ООП
- Офіційна документація Python

---

